<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LWPR Library: include/lwpr_math.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>include/lwpr_math.h File Reference</h1>Prototypes for some rather simple vector and matrix operations. <a href="#_details">More...</a>
<p>

<p>
<a href="lwpr__math_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwpr__math_8h.html#5f09c8d910199683be4f028857ef353f">lwpr_math_norm2</a> (const double *x, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the square norm of a vector of doubles.  <a href="#5f09c8d910199683be4f028857ef353f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwpr__math_8h.html#f59dc0eb341b4f083ed7c60c0df58f3a">lwpr_math_dot_product</a> (const double *a, const double *b, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the dot product between two vectors of doubles.  <a href="#f59dc0eb341b4f083ed7c60c0df58f3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwpr__math_8h.html#35c39d5895a3541bd1e829e6014d5f70">lwpr_math_scalar_vector</a> (double *y, double a, const double *x, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies a vector by a scalar and stores the result in another vector.  <a href="#35c39d5895a3541bd1e829e6014d5f70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwpr__math_8h.html#d805837b8bdb0f818fb4898de3398b8b">lwpr_math_add_scalar_vector</a> (double *y, double a, const double *x, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies a vector by a scalar and adds the result to another vector.  <a href="#d805837b8bdb0f818fb4898de3398b8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwpr__math_8h.html#492130b6054768e33c101e72db8dfdce">lwpr_math_scale_add_scalar_vector</a> (double b, double *y, double a, const double *x, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies a vector by a scalar and adds the result to another vector, which is scaled before the addition.  <a href="#492130b6054768e33c101e72db8dfdce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwpr__math_8h.html#b531b5398da2143c9ca312d66836397f">lwpr_math_cholesky</a> (int N, int Ns, double *R, const double *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the Cholesky decomposition of a matrix.  <a href="#b531b5398da2143c9ca312d66836397f"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Prototypes for some rather simple vector and matrix operations. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="d805837b8bdb0f818fb4898de3398b8b"></a><!-- doxytag: member="lwpr_math.h::lwpr_math_add_scalar_vector" ref="d805837b8bdb0f818fb4898de3398b8b" args="(double *y, double a, const double *x, int n)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void lwpr_math_add_scalar_vector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double *&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Multiplies a vector by a scalar and adds the result to another vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>Output vector, must point to an array of <em>n</em> doubles </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>a</em>&nbsp;</td><td>Scalar multiplier </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>Input vector, must point to an array of <em>n</em> doubles </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>Length of the vectors</td></tr>
  </table>
</dl>
Computes <p class="formulaDsp">
<img class="formulaDsp" alt="\[\mathbf{y} \leftarrow \mathbf{y} + a\mathbf{x}\quad\Leftrightarrow\quad y_i \leftarrow y_i + a x_i \quad i=1\dots n\]" src="form_7.png">
<p>
     </td>
  </tr>
</table>
<a class="anchor" name="b531b5398da2143c9ca312d66836397f"></a><!-- doxytag: member="lwpr_math.h::lwpr_math_cholesky" ref="b531b5398da2143c9ca312d66836397f" args="(int N, int Ns, double *R, const double *A)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int lwpr_math_cholesky           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Ns</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double *&nbsp;</td>
          <td class="mdname" nowrap> <em>A</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the Cholesky decomposition of a matrix. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>Number of columns and rows of the matrix </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Ns</em>&nbsp;</td><td>Stride parameter, i.e. offset between the first element of adjacent columns </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>R</em>&nbsp;</td><td>Upper triangular Cholesky factor. Also serves as input matrix if <em>A==NULL</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>Matrix to decompose. May be NULL, in which case the decomposition of R is done in place. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>1 in case of succes</li><li>0 in case of failure (e.g. input matrix is not positive definite)</li></ul>
</dd></dl>
Given a positive definite matrix <em>A</em>, this function computes an upper triangular matrix <em>R</em> such that <p class="formulaDsp">
<img class="formulaDsp" alt="\[\mathbf{R}^T\mathbf{R} = \mathbf{A}.\]" src="form_9.png">
<p>
 Since the decomposition is done in place, you can also call <div class="fragment"><pre class="fragment">   <a class="code" href="lwpr__math_8h.html#b531b5398da2143c9ca312d66836397f">lwpr_math_cholesky</a>(n,n,R,NULL);
</pre></div> if you can afford to overwrite the original contents of the matrix.     </td>
  </tr>
</table>
<a class="anchor" name="f59dc0eb341b4f083ed7c60c0df58f3a"></a><!-- doxytag: member="lwpr_math.h::lwpr_math_dot_product" ref="f59dc0eb341b4f083ed7c60c0df58f3a" args="(const double *a, const double *b, int n)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double lwpr_math_dot_product           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const double *&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double *&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the dot product between two vectors of doubles. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>a</em>&nbsp;</td><td>First input vector, must point to an array of <em>n</em> doubles </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b</em>&nbsp;</td><td>Second input vector, must point to an array of <em>n</em> doubles </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>Length of the vectors </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The dot product <p class="formulaDsp">
<img class="formulaDsp" alt="\[\mathbf{a}\cdot\mathbf{b} = \sum_{i=1}^n a_i b_i\]" src="form_5.png">
<p>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5f09c8d910199683be4f028857ef353f"></a><!-- doxytag: member="lwpr_math.h::lwpr_math_norm2" ref="5f09c8d910199683be4f028857ef353f" args="(const double *x, int n)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double lwpr_math_norm2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const double *&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the square norm of a vector of doubles. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>Input vector, must point to an array of <em>n</em> doubles </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>Length of the vector </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The square norm <p class="formulaDsp">
<img class="formulaDsp" alt="\[\|\mathbf{x}\|^2 = \sum_{i=1}^n x_i^2\]" src="form_4.png">
<p>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="35c39d5895a3541bd1e829e6014d5f70"></a><!-- doxytag: member="lwpr_math.h::lwpr_math_scalar_vector" ref="35c39d5895a3541bd1e829e6014d5f70" args="(double *y, double a, const double *x, int n)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void lwpr_math_scalar_vector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double *&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Multiplies a vector by a scalar and stores the result in another vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>Output vector, must point to an array of <em>n</em> doubles </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>a</em>&nbsp;</td><td>Scalar multiplier </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>Input vector, must point to an array of <em>n</em> doubles </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>Length of the vectors</td></tr>
  </table>
</dl>
Computes <p class="formulaDsp">
<img class="formulaDsp" alt="\[\mathbf{y} \leftarrow a\mathbf{x}\quad\Leftrightarrow\quad y_i \leftarrow a x_i \quad i=1\dots n\]" src="form_6.png">
<p>
     </td>
  </tr>
</table>
<a class="anchor" name="492130b6054768e33c101e72db8dfdce"></a><!-- doxytag: member="lwpr_math.h::lwpr_math_scale_add_scalar_vector" ref="492130b6054768e33c101e72db8dfdce" args="(double b, double *y, double a, const double *x, int n)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void lwpr_math_scale_add_scalar_vector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double *&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Multiplies a vector by a scalar and adds the result to another vector, which is scaled before the addition. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b</em>&nbsp;</td><td>Scalar multiplier for <em>y</em> before the addition </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>Output vector, must point to an array of <em>n</em> doubles </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>a</em>&nbsp;</td><td>Scalar multiplier for <em>x</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>Input vector, must point to an array of <em>n</em> doubles </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>Length of the vectors</td></tr>
  </table>
</dl>
Computes <p class="formulaDsp">
<img class="formulaDsp" alt="\[\mathbf{y} \leftarrow b\mathbf{y} + a\mathbf{x}\quad\Leftrightarrow\quad y_i \leftarrow b y_i + a x_i \quad i=1\dots n\]" src="form_8.png">
<p>
     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Apr 2 13:44:43 2008 for LWPR Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
